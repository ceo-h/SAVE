// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";

contract ChainSave is Ownable {
    IERC20 public usdt;
    uint256 public totalLocked;
    uint256 public bonusPool;
    uint256 public constant FEE_RATE = 50; // 0.5%
    uint256 public constant PENALTY_RATE = 100; // 1%

    struct Challenge {
        uint256 targetAmount;
        uint256 deposited;
        uint256 startTime;
        uint256 durationDays;
        bool completed;
    }

    mapping(address => Challenge) public challenges;

    constructor(address _usdt, address initialOwner) Ownable(initialOwner) {
        usdt = IERC20(_usdt);
    }

    function createChallenge(uint256 targetAmount, uint256 durationDays) external {
        require(targetAmount > 0, "Amount > 0");
        require(durationDays > 0, "Days > 0");

        Challenge storage c = challenges[msg.sender];
        require(c.deposited == 0, "Challenge exists");

        usdt.transferFrom(msg.sender, address(this), targetAmount);
        totalLocked += targetAmount;

        c.targetAmount = targetAmount;
        c.deposited = targetAmount;
        c.startTime = block.timestamp;
        c.durationDays = durationDays;
        c.completed = false;
    }

    function completeChallenge() external {
        Challenge storage c = challenges[msg.sender];
        require(c.deposited > 0, "No challenge");
        require(block.timestamp >= c.startTime + c.durationDays * 1 days, "Not ended");

        uint256 fee = c.targetAmount * FEE_RATE / 10000;
        uint256 penalty = c.targetAmount * PENALTY_RATE / 10000;
        uint256 payout = c.targetAmount - fee - penalty;

        bonusPool += penalty;
        totalLocked -= c.targetAmount;

        usdt.transfer(msg.sender, payout);
        usdt.transfer(owner(), fee);

        c.completed = true;
    }

    function emergencyWithdraw() external onlyOwner {
        usdt.transfer(owner(), usdt.balanceOf(address(this)));
    }
}
